title: poj 3974 最长连续回文串 manachers algorithm
date: 2014-09-22 23:31:10
tags: 算法
---

先把原题翻译一下
> 描述
> ------
> 聪明的计算机学生 Andy 正在思考一个教授问他一个简单问题：“你能写出一个找到一个字符串中最长回文子串的有效算法吗？”
>
> 如果一个字符串正着读和反着读都相同的话，那么它就是一个回文串，比如说“madam”是一个回文串而“acm”就不是。
> 
> 学生们意识到这可能是一个经典算法，但是出了枚举出每一个子串并判断它是不是回文串以外，都想不出一个更有效的算法。一会儿，Andy 举手说，“我有一个好方法”，但他有停了一下说，“还有一个更好的方法”。
>
> 如果你认为你知道 Andy 最后的答案，请说出来！你要在一个最多 1000000 个字符的字符串中找到最长的回文子串，并打印出他的长度。
> 
> 输入
> ------
> 你的代码将会被测试至多 30 次，每次会给出一个最长 1000000 个字符的小写字符串。输入以一个 “END” 行结束。

> 输出
> ------
> 对每一个测试用例，给出最长回文子串的长度。
> 
> 栗子
> ------
> abcbabcbabcba
>
> abacacbaaaab
>
> END
> 
> 栗子输出
> ------
> Case 1: 13
>
> Case 2: 6

<!-- more -->

第一反应：穷举法
------
> 学生们意识到这可能是一个经典算法，但是出了枚举出每一个子串并判断它是不是回文串以外，都想不出一个更有效的算法。

不让用！！！

O(n*n) 算法（不知道怎么用 markdown 打出来 n 的平方，各位先凑活着看吧）
------
首先解决一个比较恼人的问题，对于回文字符串，可以根据长度分成两种——长度为奇数和长度为偶数。对于长度为奇数的回文串，它的对称中心是一个字符，像`abcdcba`，对称中心就是`d`；而对于长度为偶数的回文串，像`abccba`，它的对称中心就在两个`c`之间。有个大牛想出来一种巧妙的方法，在原字符串的开头、结尾和每个字符之间加一个字符串中没有的字符进去，比如原题说

> 每次会给出一个最长 1000000 个字符的小写字符串

那么这个字符就可以是`#`，这样处理后的字符串`s`就一定是一个长度为奇数的字符串了，这就解决了分情况讨论的问题。

接下来，定义一个整型数组`P`，`P[]`与`s[]`的长度相同，`P[i]`代表以`s[i]`为中心的回文串的半径。举个例子：

    s  #  a  #  b  #  c  #  c  #  b  #  a  #
    P  1  2  1  2  1  2  6  2  1  2  1  2  1

再举个栗子：

    s  #  a  #  b  #  a  #  c  #  a  #  c  #  b  #  a  #  a  #  a  #  a  #  b  #
    P  1  2  1  4  1  2  1  4  1  4  1  2  1  2  1  2  3  4  7  4  3  2  1  2  1


有了这个`P`数组，只要取出`P`数组中最大的那个值，与它对应的`s`中的字符便是最大回文子串的对称中心。那么，长度怎么算呢？有大牛证明过了，最大回文子串的长度就是`P`中的最大值（最大半径）减一。

代码呼之欲出（只写初始化`P`数组的代码）

```c
void buildP(char *str, int P, int len) {
    P[0] = 1;
    for (int i = 1; i &lt; len; i++) {
        for (P[i] = 1; P[i] &lt;= i &amp;&amp; P[i]+i &lt; len &amp;&amp; str[i-P[i]] == str[i+P[i]]; P[i]++);  //注意防止越界
    }
} 
```

O(n) 算法
------
很遗憾，OJ要求太高，还得上面的算法是过不了的，还得修改。突破点在哪？当我们知道了`P`的前`i-1`个值的时候，能不能利用这些前面的值，减少第`i`个值的计算呢？

仔细观察之前的栗子

    i   0   1   2   3   4   5   6   7   8   9  10  11  12 
    s   #   a   #   b   #   c   #   c   #   b   #   a   #
    P   1   2   1   2   1   2   6   2   1   2   1   2   1

这是一个完全的回文串，以两个`c`之间的`#`为对称轴，这个字符串的`P`数组有一个规律——以 6 为界，`P`值是左右对称的。这是巧合吗？想想也不是，因为字符串左右的完全对称的，那么不难证明`P`值也一定是对称的。

利用这一规律，可以简化`P`的初始化。假设已经算到了这

    i  0   1   2   3   4   5   6   7   8   9  10  11  12 
    s  #   a   #   b   #   c   #   c   #   b   #   a   #
    P  1   2   1   2   1   2   6   ?

由于`P`值是以`i = 6`为中心左右对称的，所以`P[7] = P[2*6 - 7] = P[5] = 2`，`P[8] = P[2*6 - 8] = P[4] = 1`。但这只是针对`s`是一个完全左右对称的字符串而言的，如果`s`不是呢？

其实上面的结论可以进一步推广一下，如果字符串`s`的某个回文子串`s'`的对称中心是`i`，回文子串的半径是`r`，那么在`P`数组中，索引`i-r`到`i+r`的值，__可能__是对称的。接着看栗子：

      |<--------------------|-------------------->|
            |<--------------------------|-------------------------->|
    i  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28
    s  #  b  #  a  #  b  #  c  #  b  #  a  #  b  #  c  #  b  #  a  #  c  #  c  #  b  #  a  #
    P  1  2  1  4  1  2  1  8  1  2  1 10  1  2  1  ?

利用上述推论，`P[12] = P[2*11 - 12] = P[10] = 2`，`P[13] = P[9] = 2`，`P[14] = P[8] = 1`，这三个结果显然是正确的。但是到了`P[15]`，如果继续套用上述公式的话，就会出现错误，这是为什么呢？因为它违背了本节开始提出的那个基本规律，那就是要求字符串必须是一个完全的回文串。

对于`P[12]`、`P[13]`、`P[14]`，由于他们的半径都没有超出以`P[11]`为对称中心的回文串的最大范围，因此局部上来说，这相当于一个完全的回文串。但是对于`P[15]`的对称值`P[7]`，由于`P[7]`的半径是 8，已经穿越了以`P[11]`为对称中心的回文串的下界 2，这个回文串就变得不是完全对称的回文串了，计算方法便需要修改。此时可以注意到，既然以 7 为对称中心，半径为 8 的字符串是一个回文串，那么以 7 为对称中心半径为 6 的字符串也一定是一个回文串，这样一缩小范围，以 7 为对称中心的这个字符串又回到了以 11 为对称中心半径为 10 的字符串的范围之内，可以接着使用那个规律`P[15] = P[7] = __6__`。可是这个 6 只是一个下界，上界在哪，只好用上一节的代码接着探索了。

这样，就可以看出这个规律得全貌了。

> 对于字符串 s 得回文子串 s'，如果它是以第 i 个字符为对称轴，半径为 r 的话，[i, i+r]的 P 值满足一下规律：
>> P[j] >= min(P[2*i - j], i+r - j)

那么上一节的代码可以进一步完善了：

```c
void buildP(char *str, int P, int len) {
    int maxBounds = 1;
    int maxCenter = 0;
    P[0] = 1;
    for (int i = 1; i &lt; len; i++) {
        P[i] = min(P[2*maxCenter - i], maxBounds - i);
        for (; P[i] &lt;= i &amp;&amp; P[i]+i &lt; len &amp;&amp; str[i-P[i]] == str[i+P[i]]; P[i]++);  //注意防止越界
    }
} 
```

讲到这里，总体的 Manacher's 可以告一段落了，但是防止越界的判断还是略显啰嗦。有大牛想出了一个哨兵的方法，在字符串的开头加一个`@`，由于这个`@`与所有的字符都不同，因此一切比较到此都会停止，也就不用担心越界了。最终代码如下：

```c 
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define MAX_LEN 2000002

char str1[MAX_LEN], str2[MAX_LEN];
int p[MAX_LEN];

int min(int a, int b) {
    return a &gt; b ? b : a;
}

int main() {
    int i, j;
    int maxBounds, maxCenter, length;
    int caseNo = 1;
    int str1len, str2len;

    scanf("%s", str1);
    while (strcmp(str1, "END") != 0) {

        str2[0] = '@';
        str1len = strlen(str1);
        str2len = str1len * 2 + 2;
        for (i = 0; i &lt; str1len; i++) {
            str2[2*i+1] = '#';
            str2[2*i+2] = str1[i];
        }    
        str2[2*i+1] = '#';
        str2[2*i+2] = '\0';

        maxBounds = 0;
        maxCenter = 0;
        length = 1;
        p[0] = 1;
        for (i = 1; i &lt; str2len; i++) {
            if (maxBounds &gt; i) {
                p[i] = min(p[2*maxCenter-i], maxBounds-i);
            } else {
                p[i] = 1;
            }

            for (; str2[i-p[i]] == str2[i+p[i]]; p[i]++);
            if (i+p[i] &gt; maxBounds) {
                maxBounds = i+p[i];
                maxCenter = i;
            }
            if (length &lt; p[i]) {
                length = p[i];
            }
        }

        printf("Case %d: %d\n", caseNo, length-1);
        caseNo++;

        scanf("%s", str1);
    }

    return 0;
} 
```

_参考文献_

* [最长连续回文串（Longest Palindromic Substring）](http://blog.csdn.net/hopeztm/article/details/7932245)
